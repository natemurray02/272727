socket.on('leaveSeat', () => {
  const table = tables.get(socket.tableCode);
  if (!table) return;
  
  const seatIdx = socket.seatIdx;
  if (seatIdx !== undefined && table.seats[seatIdx]) {
    const player = table.seats[seatIdx];
    
    // If hand in progress, fold them
    if (table.handInProgress && table.gameState.players[seatIdx]) {
      table.gameState.players[seatIdx].folded = true;
    }
    
    table.seats[seatIdx] = null;
    table.gameState.players[seatIdx] = null;
    socket.seatIdx = undefined;
    
    io.to(table.code).emit('playerLeft', { name: player.name, seatIdx });
    socket.emit('seatLeft');
    
    // Send updates
    table.seats.forEach((p, i) => {
      if (p) {
        io.to(p.socketId).emit('tableUpdate', {
          seats: table.seats.map(pl => pl ? { name: pl.name, chips: pl.chips, id: pl.id, sittingOut: pl.sittingOut } : null),
          gameState: getPublicGameState(table, p.id),
          phase: table.phase,
          isPrivate: table.isPrivate,
          code: table.code
        });
      }
    });
    
    // Also send to spectators (socket without seat)
    socket.emit('tableUpdate', {
      seats: table.seats.map(pl => pl ? { name: pl.name, chips: pl.chips, id: pl.id, sittingOut: pl.sittingOut } : null),
      gameState: getPublicGameState(table, null),
      phase: table.phase,
      isPrivate: table.isPrivate,
      code: table.code
    });
    
    broadcastTableList();
  }
});

socket.on('takeSeat', ({ seatIdx, name, buyIn }) => {
  const table = tables.get(socket.tableCode);
  if (!table) return;
  
  // Check if seat is empty
  if (table.seats[seatIdx] !== null) {
    socket.emit('error', { message: 'Seat is taken' });
    return;
  }
  
  // If player is already seated somewhere, move them
  if (socket.seatIdx !== undefined && table.seats[socket.seatIdx]) {
    const oldSeat = socket.seatIdx;
    const oldPlayer = table.seats[oldSeat];
    
    // Move player to new seat
    table.seats[seatIdx] = oldPlayer;
    table.gameState.players[seatIdx] = oldPlayer;
    table.seats[oldSeat] = null;
    table.gameState.players[oldSeat] = null;
    
    socket.seatIdx = seatIdx;
    socket.emit('seatTaken', { seatIdx });
    
    io.to(table.code).emit('playerJoined', { name: oldPlayer.name, seatIdx });
  } else {
    // New player taking seat
    const player = {
      id: socket.id,
      name,
      chips: buyIn || table.defaultBuyIn,
      cards: [],
      folded: false,
      allIn: false,
      sittingOut: table.handInProgress,
      socketId: socket.id
    };
    
    table.seats[seatIdx] = player;
    table.players.push(player);
    table.gameState.players[seatIdx] = player;
    
    socket.seatIdx = seatIdx;
    socket.emit('seatTaken', { seatIdx });
    
    io.to(table.code).emit('playerJoined', { name, seatIdx });
  }
  
  // Send updates to everyone
  table.seats.forEach((p, i) => {
    if (p) {
      io.to(p.socketId).emit('tableUpdate', {
        seats: table.seats.map(pl => pl ? { name: pl.name, chips: pl.chips, id: pl.id, sittingOut: pl.sittingOut } : null),
        gameState: getPublicGameState(table, p.id),
        phase: table.phase,
        isPrivate: table.isPrivate,
        code: table.code
      });
    }
  });
  
  broadcastTableList();
});
